<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<style>
    html,
    body {
        padding: 0;
        margin: 0;
        height: 100%;
        background-color: lavenderblush;
    }
</style>

<body>

</body>
<script>
    /*~ function () {
        function check(n) {
            n = Number(n);
            return isNaN(n) ? 0 : n;
        }

        function add(n) {
            n = check(n);
            return this + n;
        }

        function minus(n) {
            n = check(n);
            return this - n;
        }

        function myIndex(T) {
            let reg = new RegExp(T)
            res = reg.exec(this);
            return res === null ? -1 : res.index;
        }



        String.prototype.myIndex = myIndex;
        // Number.prototype.add = add;
        // Number.prototype.minus = minus;
        ['add', 'minus'].forEach(item => {
            Number.prototype[item] = eval(item);
        });

    }();
    console.log((5).add(3).minus(2));


    let str = 'ChangShangXueYuan',
        T = 'xue';

    console.log(str.myIndex(T));*/

    // str = str.replace(/[a-zA-Z]/g, context => {
    //     // return context.toUpperCase() === context ? context.toLowerCase() : context.toUpperCase()
    //     return (context.charCodeAt() > 65 && context.charCodeAt() < 90) ? context.toLowerCase() : context
    //         .toUpperCase();
    // })
    // console.log(str);

    //---------------------------------------------------------------------------------------

    /*function Foo() {
        Foo.a = function () {
            console.log(1);
        }
        this.a = function () {
            console.log(2);
        }
    }
    //把Foo当做类，在原型上设置类的公有属性方法=>实例.a();
    Foo.prototype.a = function () {
        console.log(3);
    }
    //把Foo当做普通对象设置私有属性方法=>Foo.a();
    Foo.a = function () {
        console.log(4);
    }
    Foo.a(); //=>4
    //先把Foo执行生成私有属性域，obj为Foo的实例可以调取原型上的方法，当私有域中有方法时优先调用私有域中的方法
    let obj = new Foo();
    obj.a(); //=>2
    Foo.a(); //=>1*/


    //----------------------------------------------------------------------------------

    /*function Dog(name) {
        this.name = name;
    }
    Dog.prototype.brake = function () {
        console.log('WangWangWang')
    }
    Dog.prototype.sayName = function () {
        console.log('my name is' + this.name);
    }

    //手写new方法
    function _new(fn, ...arg) {
        //创建一个对象
        // let obj = {};
        //让他的原型链指向fn.prototype(作为fn的一个实例)，实例的原型链(__proto__)指向所属类的原型(prototype)
        // obj.__proto__ = fn.prototype;
        //Object.create([A])=>创建一个空对象，并且让空对象作为A对象所属构造函数的实例
        let obj = Object.create(fn.prototype);
        //让当前函数的this指向obj实例，并传递参数
        fn.call(obj, ...arg);
        return obj;
    }

    let san = _new(Dog, '三毛');
    san.brake();
    san.sayName();
    console.log(san instanceof Dog);*/

    //-------------------------------------------------------------------------------

    /*let ary1 = ["A1", "B2", "A2", "C1", "B1", "D1", "C2", "D2"],
        ary2 = ["D", "C", "B", "A"],
        C = ary1.slice();
    let arr = [],
        n = 0;

    console.time('a');
    for (let i = 0; i < ary2.length; i++) {
        let item2 = ary2[i];
        console.log(1);
        for (let j = 0; j < C.length; j++) {
            console.log(2);
            let item1 = C[j];
            if (item1.includes(item2)) {
                arr.push(item1);
                C.splice(j, 1);
                j--;
            }
        }
        arr.push(item2);
    }
    console.timeEnd('a');
    console.log(arr);

    console.time('b');
    for (let i = 0; i < ary2.length; i++) {
        let item2 = ary2[i];
        console.log(1);
        for (let j = 0; j < ary1.length; j++) {
            console.log(2);
            let item1 = ary1[j];
            if (item1.includes(item2)) {
                n = j;
            }
        }
        ary1.splice(n + 1, 0, item2);
    }
    console.timeEnd('b');
    console.log(ary1);*/


    //-------------------------------------------------------------------------------

    /*var b = 10;
    (function b() {
        b = 20;
        console.log(b); //=>b这个函数本身
    })()
    console.log(b); //=>10
    //1.本来应该匿名的函数如果设置了函数名，在外面还是无法调用的，但是在函数里面是可以使用的
    //2.而且类似于创建常量一样，b这个值被创建了以后就不能被修改（非严格模式下不会报错，但是没有任何效果，
    //严格模式下直接报错，可以理解b使用const创建的）

    var b = 10;
    (function b() {
        var b = 20;
        console.log(b); //=>20
    })()
    console.log(b); //=>10

    var b = 10;
    (function b(b) {
        b = 20;
        console.log(b); //=>20
    })()
    console.log(b); //=>10*/

    //---------------------------------------------------------------------------------

    /*1.{}=={}两个对象比较，比较的是堆内存地址
    2.nll == undefined 相等 / null===undefined 不相等
    3.NAN==NAN 不相等 NAN和谁都不相等
    4.[12]=="12" 对象和字符串比较，是把对象toString()转化为字符串后再进行比较
    5.剩余所有的情况在比较的时候，都是转换为数字(前提是数据类型不一样)
    对象转数字：先转换为字符串再转为数字
    字符串转数字：只要出现一个非数字字符，结果就是NAN
    [12]==true //=>Number([12].toString())==Number(true)
    undefined转数字NaN
    */

    //对象和数字比较：先把对象.toString()变成字符串再转换为数字比较;
    /*let a = {
        n: 0,
        toString: function () {
            return ++this.n;
        }
    }
    //a.toString(); //=>此时调取的是a的私有作用域上的toString,而不是对象的原型上的
    if (a == 1 && a == 2 && a == 3) {
        console.log('OK');
    }*/


    //shift :删除数组第一项，把删除的内容返回，原有数组改变
    /*let a = [1, 2, 3];
    a.toString = a.shift;
    if (a == 1 && a == 2 && a == 3) {
        console.log('OK');
    }*/


    /*Object.defineProperty(window, 'a', {
        get: function () {
            //判断传进来的值存不存在，存在就+1否则赋值为1
            this.value ? this.value++ : this.value = 1;
            return this.value
        }
    });
    if (a == 1 && a == 2 && a == 3) {
        console.log('OK');
    }*/

    //--------------------------------------------------------------------------

    //Array.prototype.push方法源码
    /*function pu(val) {
        this[this.length] = val;
        //=>this.length会自动累加1，浏览器自动处理，数组原理
        return this.length;
    }*/

    /*let obj = {
        3: 4,
        4: 5,
        length: 2,
        push: Array.prototype.push
    }
    obj.push(1); //=>  obj[obj.length]=1 => obj[2]=1 =>obj.length=3
    obj.push(2); //=>  obj[obj.length]=2 => obj[3]=2 =>obj.length=4
    console.log(obj); //=>{2: 1, 3: 2, 4: 5, length: 4, push: ƒ}*/

    //------------------------------------------------------------------------

    /*let ary = [1, 56, 2, 23, 15, 45, 12, 24];

    function bubble(ary) {
        for (let i = 0; i < ary.length - 1; i++) {
            let flag = 1;
            for (let j = 0; j < ary.length - 1 - i; j++) {
                ary[j] > ary[j + 1] ? [ary[j], ary[j + 1]] = [ary[j + 1], ary[j]] : null;
                flag = 0;
            }
            if (flag) {
                return ary;
            }
        }
        return ary;
    }

    function insert(ary) {
        let handler = [];
        handler.push(ary[0]);
        for (let i = 1; i < ary.length; i++) {
            let A = ary[i];
            for (let j = handler.length - 1; j >= 0; j--) {
                let B = handler[j];
                if (A > B) {
                    handler.splice(j + 1, 0, A);
                    break;
                }
                if (j === 0) {
                    handler.unshift(A);
                }
            }
        }
        return handler;
    }

    function quick(ary) {
        if (ary.length <= 1) {
            return ary;
        }
        let minIn = Math.floor(ary.length / 2),
            minVal = ary.splice(minIn, 1)[0],
            leftAry = [],
            rightAry = [];
        for (let i = 0; i < ary.length; i++) {
            let item = ary[i];
            item < minVal ? leftAry.push(item) : rightAry.push(item);
        }
        return quick(leftAry).concat(minVal, quick(rightAry));
    }
    console.log(bubble(ary));
    console.log(insert(ary));
    console.log(quick(ary));
    console.log(ary);*/

    //---------------------------------------------------------------------------
    /*let obj = {
        1: 222,
        2: 123,
        5: 111
    };

    //let arr = new Array(12).fill(null).map((item, index) => obj[index + 1] || null)

    let arr = new Array(12).fill(null);
    Object.keys(obj).forEach(item => {
        arr[item - 1] = obj[item];
    });
    console.log(arr);*/

    //-------------------------------------------------------------------------------

    /*let ary = [1, 2, 3, 4, 5, 6, 7, 8];

    function rotate(n) {
        if (n === 0 || n < 0 || n === this.length) return;
        if (n > this.length) n = n % this.length;

        // return this.slice(-n).concat(this.slice(0, -n));

        //return [...this.splice(-n), ...this] //=>this.splice(-n).concat(this);
        for (let i = 0; i < n; i++) {
            this.unshift(this.pop());
        }
        return this;
    }
    Array.prototype.rotate = rotate;
    console.log(ary.rotate(6))*/

    //-------------------------------------------------------------------------------
    //柯理化函数:函数执行生成闭包保存数据，利用了闭包的保存机制
    /*~ function () {
        function myBind(context = window, ...outArg) {
            _this = this;
            return function (...innerArg) {
                _this.call(context, ...outArg.concat(innerArg))
            }
        }
        Function.prototype.myBind = myBind;
    }();
    let obj = {
        name: '名字'
    }

    function fn(...arg) {
        console.log(this, arg)
    }

    document.body.onclick = fn.myBind(null, 100, 200);*/

    function currying(fn, length) {
        length = length || fn.length
        return function (...args) {
            if (args.length >= length) {
                return fn(...args);
            }
            return currying(fn.bind(null, ...args), length - args.length);
        }
    }
    let add = currying((...arg) => eval(arg.join('+')), 5);

    console.log(add(1)(2, 3)) //=>15
</script>

</html>